import 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js';
import { workerEvents } from '../events/constants.js';

console.log('Model training worker initialized');
let _globalCtx = {};

const WEIGHTS = {
    category: 0.4,
    color: 0.3,
    price: 0.2,
    age: 0.1,
}

// Normalize continuous values (price, age) to 0-1 range
// Why? Keeps all features balanced so no one dominates training
// Formula: (val - min) / (max - min) 
const normalize = (val, min, max) => (val - min) / ((max - min) || 1);



function makeContext(products, users) {
    // Normalização e preparação dos dados para treinamento
    const ages = users.map(u => u.age);
    const prices = products.map(p => p.price);
    const minAge = Math.min(...ages);
    const maxAge = Math.max(...ages);
    
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);

    const colors = [...new Set(products.map(p => p.color))];
    const categories = [...new Set(products.map(p => p.category))];

    const colorIndex = Object.fromEntries(colors.map((c, i) => {return [c, i]}));
    const categoriesIndex = Object.fromEntries(categories.map((c, i) => { return [c, i]}));

    // Computar a média de idade dos usuários para usar como baseline
    const midAge = (minAge + maxAge) / 2;
    const ageSums = {};
    const ageCounts = {};

    users.forEach(u => {
        u.purchases.forEach(p => {
           ageSums[p.name] = (ageSums[p.name] || 0) + u.age;
           ageCounts[p.name] = (ageCounts[p.name] || 0) + 1;
        });

    });

    const productAverages = Object.fromEntries(
        products.map( product => {
        const avg = ageCounts[product.name] ? 
            ageSums[product.name] / ageCounts[product.name] : midAge;

        return [product.name, normalize(avg, minAge, maxAge)];
    }));

    return {
        products,
        users,
        colorIndex,
        categoriesIndex,
        productAverages,
        minAge,
        maxAge,
        minPrice,
        maxPrice,
        numCategories: categories.length,
        numColors: colors.length,
        // age, price + one-hot colors + one-hot categories
        dimentions: 2 + colors.length + categories.length, 
    }
}

const oneHotWeighted = (index, length, weight) => 
    tf.oneHot(index, length).cast('float32').mul(weight);

function encodeProduct(product, context) {

    const price = tf.tensor1d([
        normalize(
            product.price, 
            context.minPrice, 
            context.maxPrice
        ) * WEIGHTS.price
    ]);

    const age = tf.tensor1d([
        (
            context.productAverages[product.name] ?? 0.5
        ) * WEIGHTS.age
    ]);

    const category = oneHotWeighted(
        context.categoriesIndex[product.category], 
        context.numCategories, 
        WEIGHTS.category
    );

    const color = oneHotWeighted(
        context.colorIndex[product.color], 
        context.numColors, 
        WEIGHTS.color
    );

    return tf.concat1d([price, age, category, color]);
}

function encodeUser(user, context) {
    if (user.purchases.length) {
        return tf.stack(
            user.purchases.map(p => {
                const product = context.products.find(prod => prod.name === p.name);
                return encodeProduct(product, context);
            })
        )
        .mean(0)
        .reshape([1, context.dimentions]);
    }
}

function createTrainingData(context) {
    const inputs = [];
    const labels = [];
    context.users.forEach(user => {
        const userVector = encodeUser(user, context).dataSync();
        context.products.forEach(product => {
            const productVector = encodeProduct(product, context).dataSync();
            const label = user.purchases.some(p => p.name === product.name) ? 1 : 0;
            inputs.push([...userVector, ...productVector]);
            labels.push(label);
        });
    });

    return {
        xs: tf.tensor2d(inputs),
        ys: tf.tensor2d(labels, [labels.length, 1]),
        inputDimention: context.dimentions * 2,
        // tamanho = userVector + productVector
    };
}

async function trainModel({ users }) {
    console.log('Training model with users:', users)

    postMessage({ type: workerEvents.progressUpdate, progress: { progress: 50 } });
    const products = await fetch('/data/products.json').then(res => res.json());

    const context = makeContext(products, users);
    context.productVectors = products.map(product => {

        return {
            name: product.name,
            meta: {...product},
            vector: encodeProduct(product, context).dataSync()
        };
    });

    _globalCtx = context;

    const trainData = createTrainingData(context);

    postMessage({
        type: workerEvents.trainingLog,
        epoch: 1,
        loss: 1,
        accuracy: 1
    });

    setTimeout(() => {
        postMessage({ type: workerEvents.progressUpdate, progress: { progress: 100 } });
        postMessage({ type: workerEvents.trainingComplete });
    }, 1000);


}
function recommend(user, ctx) {
    console.log('will recommend for user:', user)
    // postMessage({
    //     type: workerEvents.recommend,
    //     user,
    //     recommendations: []
    // });
}


const handlers = {
    [workerEvents.trainModel]: trainModel,
    [workerEvents.recommend]: d => recommend(d.user, _globalCtx),
};

self.onmessage = e => {
    const { action, ...data } = e.data;
    if (handlers[action]) handlers[action](data);
};
